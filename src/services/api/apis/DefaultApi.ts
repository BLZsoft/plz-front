/* tslint:disable */
/* eslint-disable */
/**
 * пожликбез.рф API
 * API спецификация пожликбез.рф
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  CreateObjectDto,
  CreateOwnerDto,
  ObjectEntity,
  ObjectsControllerAddOwner400Response,
  ObjectsControllerFind200Response,
  ObjectsControllerFind401Response,
  ObjectsControllerFindOne404Response,
  ObjectsControllerGetOwners200Response,
  ObjectsControllerRemoveOwner400Response,
  ObjectsControllerRemoveOwner404Response,
  OwnerEntity,
  UpdateObjectDto,
} from '../models';
import {
  CreateObjectDtoFromJSON,
  CreateObjectDtoToJSON,
  CreateOwnerDtoFromJSON,
  CreateOwnerDtoToJSON,
  ObjectEntityFromJSON,
  ObjectEntityToJSON,
  ObjectsControllerAddOwner400ResponseFromJSON,
  ObjectsControllerAddOwner400ResponseToJSON,
  ObjectsControllerFind200ResponseFromJSON,
  ObjectsControllerFind200ResponseToJSON,
  ObjectsControllerFind401ResponseFromJSON,
  ObjectsControllerFind401ResponseToJSON,
  ObjectsControllerFindOne404ResponseFromJSON,
  ObjectsControllerFindOne404ResponseToJSON,
  ObjectsControllerGetOwners200ResponseFromJSON,
  ObjectsControllerGetOwners200ResponseToJSON,
  ObjectsControllerRemoveOwner400ResponseFromJSON,
  ObjectsControllerRemoveOwner400ResponseToJSON,
  ObjectsControllerRemoveOwner404ResponseFromJSON,
  ObjectsControllerRemoveOwner404ResponseToJSON,
  OwnerEntityFromJSON,
  OwnerEntityToJSON,
  UpdateObjectDtoFromJSON,
  UpdateObjectDtoToJSON,
} from '../models';

export interface ObjectsControllerAddOwnerRequest {
  objectId: number;
  createOwnerDto: CreateOwnerDto;
}

export interface ObjectsControllerCreateRequest {
  createObjectDto: CreateObjectDto;
}

export interface ObjectsControllerFindRequest {
  skip?: number;
  take?: number;
}

export interface ObjectsControllerFindOneRequest {
  id: number;
}

export interface ObjectsControllerGetOwnersRequest {
  objectId: number;
  skip?: number;
  take?: number;
}

export interface ObjectsControllerRemoveRequest {
  id: number;
}

export interface ObjectsControllerRemoveOwnerRequest {
  objectId: number;
  id: string;
}

export interface ObjectsControllerUpdateRequest {
  id: number;
  updateObjectDto: UpdateObjectDto;
}

export interface ProfileControllerCreateRequest {
  username?: string;
  primaryEmail?: string;
  primaryPhone?: string;
  name?: string;
  avatar?: any;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * Добавляет владельца к объекту.
   */
  async objectsControllerAddOwnerRaw(
    requestParameters: ObjectsControllerAddOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OwnerEntity>> {
    if (requestParameters.objectId === null || requestParameters.objectId === undefined) {
      throw new runtime.RequiredError(
        'objectId',
        'Required parameter requestParameters.objectId was null or undefined when calling objectsControllerAddOwner.',
      );
    }

    if (requestParameters.createOwnerDto === null || requestParameters.createOwnerDto === undefined) {
      throw new runtime.RequiredError(
        'createOwnerDto',
        'Required parameter requestParameters.createOwnerDto was null or undefined when calling objectsControllerAddOwner.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{objectId}/owners`.replace(
          `{${'objectId'}}`,
          encodeURIComponent(String(requestParameters.objectId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateOwnerDtoToJSON(requestParameters.createOwnerDto),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => OwnerEntityFromJSON(jsonValue));
  }

  /**
   * Добавляет владельца к объекту.
   */
  async objectsControllerAddOwner(
    requestParameters: ObjectsControllerAddOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OwnerEntity> {
    const response = await this.objectsControllerAddOwnerRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Создает объект.
   */
  async objectsControllerCreateRaw(
    requestParameters: ObjectsControllerCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectEntity>> {
    if (requestParameters.createObjectDto === null || requestParameters.createObjectDto === undefined) {
      throw new runtime.RequiredError(
        'createObjectDto',
        'Required parameter requestParameters.createObjectDto was null or undefined when calling objectsControllerCreate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateObjectDtoToJSON(requestParameters.createObjectDto),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ObjectEntityFromJSON(jsonValue));
  }

  /**
   * Создает объект.
   */
  async objectsControllerCreate(
    requestParameters: ObjectsControllerCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectEntity> {
    const response = await this.objectsControllerCreateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Возвращает список объектов.
   */
  async objectsControllerFindRaw(
    requestParameters: ObjectsControllerFindRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectsControllerFind200Response>> {
    const queryParameters: any = {};

    if (requestParameters.skip !== undefined) {
      queryParameters['skip'] = requestParameters.skip;
    }

    if (requestParameters.take !== undefined) {
      queryParameters['take'] = requestParameters.take;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ObjectsControllerFind200ResponseFromJSON(jsonValue));
  }

  /**
   * Возвращает список объектов.
   */
  async objectsControllerFind(
    requestParameters: ObjectsControllerFindRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectsControllerFind200Response> {
    const response = await this.objectsControllerFindRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Возвращает указанный объект.
   */
  async objectsControllerFindOneRaw(
    requestParameters: ObjectsControllerFindOneRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectEntity>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling objectsControllerFindOne.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ObjectEntityFromJSON(jsonValue));
  }

  /**
   * Возвращает указанный объект.
   */
  async objectsControllerFindOne(
    requestParameters: ObjectsControllerFindOneRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectEntity> {
    const response = await this.objectsControllerFindOneRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Возвращает владельцев указанного объекта.
   */
  async objectsControllerGetOwnersRaw(
    requestParameters: ObjectsControllerGetOwnersRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectsControllerGetOwners200Response>> {
    if (requestParameters.objectId === null || requestParameters.objectId === undefined) {
      throw new runtime.RequiredError(
        'objectId',
        'Required parameter requestParameters.objectId was null or undefined when calling objectsControllerGetOwners.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.skip !== undefined) {
      queryParameters['skip'] = requestParameters.skip;
    }

    if (requestParameters.take !== undefined) {
      queryParameters['take'] = requestParameters.take;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{objectId}/owners`.replace(
          `{${'objectId'}}`,
          encodeURIComponent(String(requestParameters.objectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ObjectsControllerGetOwners200ResponseFromJSON(jsonValue),
    );
  }

  /**
   * Возвращает владельцев указанного объекта.
   */
  async objectsControllerGetOwners(
    requestParameters: ObjectsControllerGetOwnersRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectsControllerGetOwners200Response> {
    const response = await this.objectsControllerGetOwnersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Удаляет указанный объект.
   */
  async objectsControllerRemoveRaw(
    requestParameters: ObjectsControllerRemoveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectEntity>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling objectsControllerRemove.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ObjectEntityFromJSON(jsonValue));
  }

  /**
   * Удаляет указанный объект.
   */
  async objectsControllerRemove(
    requestParameters: ObjectsControllerRemoveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectEntity> {
    const response = await this.objectsControllerRemoveRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Удаляет владельца из объекта.
   */
  async objectsControllerRemoveOwnerRaw(
    requestParameters: ObjectsControllerRemoveOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OwnerEntity>> {
    if (requestParameters.objectId === null || requestParameters.objectId === undefined) {
      throw new runtime.RequiredError(
        'objectId',
        'Required parameter requestParameters.objectId was null or undefined when calling objectsControllerRemoveOwner.',
      );
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling objectsControllerRemoveOwner.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{objectId}/owners/{id}`
          .replace(`{${'objectId'}}`, encodeURIComponent(String(requestParameters.objectId)))
          .replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => OwnerEntityFromJSON(jsonValue));
  }

  /**
   * Удаляет владельца из объекта.
   */
  async objectsControllerRemoveOwner(
    requestParameters: ObjectsControllerRemoveOwnerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OwnerEntity> {
    const response = await this.objectsControllerRemoveOwnerRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Обновляет указанный объект
   */
  async objectsControllerUpdateRaw(
    requestParameters: ObjectsControllerUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ObjectEntity>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling objectsControllerUpdate.',
      );
    }

    if (requestParameters.updateObjectDto === null || requestParameters.updateObjectDto === undefined) {
      throw new runtime.RequiredError(
        'updateObjectDto',
        'Required parameter requestParameters.updateObjectDto was null or undefined when calling objectsControllerUpdate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/api/objects/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateObjectDtoToJSON(requestParameters.updateObjectDto),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ObjectEntityFromJSON(jsonValue));
  }

  /**
   * Обновляет указанный объект
   */
  async objectsControllerUpdate(
    requestParameters: ObjectsControllerUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ObjectEntity> {
    const response = await this.objectsControllerUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Обновляет профиль пользователя.
   */
  async profileControllerCreateRaw(
    requestParameters: ProfileControllerCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const consumes: runtime.Consume[] = [{ contentType: 'multipart/form-data' }];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.username !== undefined) {
      formParams.append('username', requestParameters.username as any);
    }

    if (requestParameters.primaryEmail !== undefined) {
      formParams.append('primaryEmail', requestParameters.primaryEmail as any);
    }

    if (requestParameters.primaryPhone !== undefined) {
      formParams.append('primaryPhone', requestParameters.primaryPhone as any);
    }

    if (requestParameters.name !== undefined) {
      formParams.append('name', requestParameters.name as any);
    }

    if (requestParameters.avatar !== undefined) {
      formParams.append('avatar', new Blob(requestParameters.avatar));
    }

    const response = await this.request(
      {
        path: `/api/profile`,
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Обновляет профиль пользователя.
   */
  async profileControllerCreate(
    requestParameters: ProfileControllerCreateRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.profileControllerCreateRaw(requestParameters, initOverrides);
  }
}
